#!/usr/bin/env node
/**
 * Real-Time CLI Streaming Test Suite
 * 
 * Comprehensive tests to validate that Claude CLI streaming works correctly
 * and provides true real-time responses without delays or hanging issues.
 */

import { claudeHeadlessStreamingService } from './src/services/ClaudeHeadlessStreamingService.js';
import { performance } from 'perf_hooks';

interface TestMetrics {
  testName: string;
  startTime: number;
  firstChunkTime?: number;
  completionTime?: number;
  totalChunks: number;
  totalBytes: number;
  success: boolean;
  error?: string;
  latency: {
    timeToFirstChunk?: number;
    totalDuration?: number;
  };
}

class StreamingTestSuite {
  private testResults: TestMetrics[] = [];
  
  async runAllTests(): Promise<void> {
    console.log('üöÄ Starting Real-Time CLI Streaming Tests\n');
    
    try {
      // Health check first
      await this.testHealthCheck();
      
      // Basic streaming tests
      await this.testBasicStreaming();
      await this.testGreetingStreaming();
      await this.testLongResponseStreaming();
      
      // Session management tests
      await this.testSessionCreation();
      await this.testMultiTurnConversation();
      
      // Performance tests
      await this.testConcurrentStreaming();
      await this.testStreamingLatency();
      
      // Error handling tests
      await this.testErrorHandling();
      await this.testTimeoutHandling();
      
      // Generate test report
      this.generateReport();
      
    } catch (error) {
      console.error('‚ùå Test suite failed:', error);
      process.exit(1);
    }
  }
  
  // ============================================================================
  // Individual Test Methods
  // ============================================================================
  
  async testHealthCheck(): Promise<void> {
    console.log('üîç Testing Health Check...');
    
    const startTime = performance.now();
    
    try {
      const health = await claudeHeadlessStreamingService.healthCheck();
      const completionTime = performance.now();
      
      if (health.available) {
        console.log(`‚úÖ Health check passed`);
        console.log(`   Version: ${health.version}`);
        console.log(`   Pool size: ${health.poolSize}`);
        console.log(`   Duration: ${(completionTime - startTime).toFixed(2)}ms\n`);
        console.log();
      } else {
        throw new Error('Claude CLI not available');\n      }\n      \n    } catch (error) {\n      console.log(`‚ùå Health check failed: ${error}\\n`);\n      throw error;\n    }\n  }\n  \n  async testBasicStreaming(): Promise<void> {\n    console.log('üß™ Testing Basic Streaming...');\n    \n    const metrics: TestMetrics = {\n      testName: 'Basic Streaming',\n      startTime: performance.now(),\n      totalChunks: 0,\n      totalBytes: 0,\n      success: false,\n      latency: {}\n    };\n    \n    try {\n      let receivedResponse = '';\n      \n      await claudeHeadlessStreamingService.streamQuery(\n        \"Say hello and explain what you can help with in 2 sentences.\",\n        {\n          timeout: 10000,\n          verbose: false\n        },\n        // onChunk\n        (chunk: string) => {\n          if (!metrics.firstChunkTime) {\n            metrics.firstChunkTime = performance.now();\n            metrics.latency.timeToFirstChunk = metrics.firstChunkTime - metrics.startTime;\n            process.stdout.write('üì• First chunk received! Streaming: ');\n          }\n          \n          process.stdout.write(chunk);\n          receivedResponse += chunk;\n          metrics.totalChunks++;\n          metrics.totalBytes += chunk.length;\n        },\n        // onComplete\n        (fullResponse: string) => {\n          metrics.completionTime = performance.now();\n          metrics.latency.totalDuration = metrics.completionTime - metrics.startTime;\n          metrics.success = true;\n          \n          console.log('\\n‚úÖ Basic streaming test completed');\n          console.log(`   Response length: ${fullResponse.length} characters`);\n          console.log(`   Chunks received: ${metrics.totalChunks}`);\n          console.log(`   Time to first chunk: ${metrics.latency.timeToFirstChunk?.toFixed(2)}ms`);\n          console.log(`   Total duration: ${metrics.latency.totalDuration?.toFixed(2)}ms\\n`);\n        }\n      );\n      \n      this.testResults.push(metrics);\n      \n    } catch (error) {\n      metrics.error = error instanceof Error ? error.message : String(error);\n      this.testResults.push(metrics);\n      \n      console.log(`‚ùå Basic streaming test failed: ${metrics.error}\\n`);\n      throw error;\n    }\n  }\n  \n  async testGreetingStreaming(): Promise<void> {\n    console.log('üëã Testing Greeting Streaming...');\n    \n    const metrics: TestMetrics = {\n      testName: 'Greeting Streaming',\n      startTime: performance.now(),\n      totalChunks: 0,\n      totalBytes: 0,\n      success: false,\n      latency: {}\n    };\n    \n    try {\n      await claudeHeadlessStreamingService.streamGreeting(\n        \"Hi there! What can you help me with?\",\n        {\n          timeout: 10000\n        },\n        (chunk: string) => {\n          if (!metrics.firstChunkTime) {\n            metrics.firstChunkTime = performance.now();\n            metrics.latency.timeToFirstChunk = metrics.firstChunkTime - metrics.startTime;\n            process.stdout.write('üì• Greeting response: ');\n          }\n          \n          process.stdout.write(chunk);\n          metrics.totalChunks++;\n          metrics.totalBytes += chunk.length;\n        },\n        (fullResponse: string) => {\n          metrics.completionTime = performance.now();\n          metrics.latency.totalDuration = metrics.completionTime - metrics.startTime;\n          metrics.success = true;\n          \n          console.log('\\n‚úÖ Greeting streaming test completed');\n          console.log(`   Time to first chunk: ${metrics.latency.timeToFirstChunk?.toFixed(2)}ms`);\n          console.log(`   Total duration: ${metrics.latency.totalDuration?.toFixed(2)}ms\\n`);\n        }\n      );\n      \n      this.testResults.push(metrics);\n      \n    } catch (error) {\n      metrics.error = error instanceof Error ? error.message : String(error);\n      this.testResults.push(metrics);\n      \n      console.log(`‚ùå Greeting streaming test failed: ${metrics.error}\\n`);\n    }\n  }\n  \n  async testLongResponseStreaming(): Promise<void> {\n    console.log('üìù Testing Long Response Streaming...');\n    \n    const metrics: TestMetrics = {\n      testName: 'Long Response Streaming',\n      startTime: performance.now(),\n      totalChunks: 0,\n      totalBytes: 0,\n      success: false,\n      latency: {}\n    };\n    \n    try {\n      await claudeHeadlessStreamingService.streamQuery(\n        \"Explain the concept of microservices architecture in detail, including benefits, challenges, and best practices.\",\n        {\n          timeout: 20000\n        },\n        (chunk: string) => {\n          if (!metrics.firstChunkTime) {\n            metrics.firstChunkTime = performance.now();\n            metrics.latency.timeToFirstChunk = metrics.firstChunkTime - metrics.startTime;\n            console.log(`\\nüì• Long response streaming (first chunk in ${metrics.latency.timeToFirstChunk?.toFixed(2)}ms)...`);\n          }\n          \n          // Show progress dots instead of full text to avoid cluttering\n          process.stdout.write('.');\n          metrics.totalChunks++;\n          metrics.totalBytes += chunk.length;\n        },\n        (fullResponse: string) => {\n          metrics.completionTime = performance.now();\n          metrics.latency.totalDuration = metrics.completionTime - metrics.startTime;\n          metrics.success = true;\n          \n          console.log('\\n‚úÖ Long response streaming test completed');\n          console.log(`   Response length: ${fullResponse.length} characters`);\n          console.log(`   Chunks received: ${metrics.totalChunks}`);\n          console.log(`   Average chunk size: ${(metrics.totalBytes / metrics.totalChunks).toFixed(1)} bytes`);\n          console.log(`   Time to first chunk: ${metrics.latency.timeToFirstChunk?.toFixed(2)}ms`);\n          console.log(`   Total duration: ${metrics.latency.totalDuration?.toFixed(2)}ms\\n`);\n        }\n      );\n      \n      this.testResults.push(metrics);\n      \n    } catch (error) {\n      metrics.error = error instanceof Error ? error.message : String(error);\n      this.testResults.push(metrics);\n      \n      console.log(`‚ùå Long response streaming test failed: ${metrics.error}\\n`);\n    }\n  }\n  \n  async testSessionCreation(): Promise<void> {\n    console.log('üîê Testing Session Creation...');\n    \n    try {\n      const sessionId = await claudeHeadlessStreamingService.createSession();\n      console.log(`‚úÖ Session created: ${sessionId}`);\n      \n      const activeSessions = claudeHeadlessStreamingService.getActiveSessions();\n      console.log(`   Active sessions: ${activeSessions.length}`);\n      \n      // Clean up\n      await claudeHeadlessStreamingService.destroySession(sessionId);\n      console.log(`   Session destroyed: ${sessionId}\\n`);\n      \n    } catch (error) {\n      console.log(`‚ùå Session creation test failed: ${error}\\n`);\n    }\n  }\n  \n  async testMultiTurnConversation(): Promise<void> {\n    console.log('üí¨ Testing Multi-Turn Conversation...');\n    \n    try {\n      const sessionId = await claudeHeadlessStreamingService.createSession();\n      console.log(`üìù Created conversation session: ${sessionId}`);\n      \n      // First message\n      console.log('\\nüë§ User: What is Node.js?');\n      process.stdout.write('ü§ñ Assistant: ');\n      \n      await claudeHeadlessStreamingService.streamInSession(\n        sessionId,\n        \"What is Node.js?\",\n        {\n          onChunk: (chunk) => process.stdout.write(chunk),\n          onComplete: () => console.log(''),\n          onStart: () => {}\n        }\n      );\n      \n      // Follow-up message\n      console.log('\\nüë§ User: What are its main advantages?');\n      process.stdout.write('ü§ñ Assistant: ');\n      \n      await claudeHeadlessStreamingService.streamInSession(\n        sessionId,\n        \"What are its main advantages?\",\n        {\n          onChunk: (chunk) => process.stdout.write(chunk),\n          onComplete: () => console.log(''),\n          onStart: () => {}\n        }\n      );\n      \n      const session = claudeHeadlessStreamingService.getActiveSessions().find(s => s.id === sessionId);\n      console.log(`\\n‚úÖ Multi-turn conversation completed`);\n      console.log(`   Messages in history: ${session?.messageHistory.length || 0}`);\n      \n      // Clean up\n      await claudeHeadlessStreamingService.destroySession(sessionId);\n      console.log(`   Session destroyed\\n`);\n      \n    } catch (error) {\n      console.log(`‚ùå Multi-turn conversation test failed: ${error}\\n`);\n    }\n  }\n  \n  async testConcurrentStreaming(): Promise<void> {\n    console.log('‚ö° Testing Concurrent Streaming...');\n    \n    const startTime = performance.now();\n    \n    try {\n      const promises = [\n        this.performQuickStream(\"What is JavaScript?\", 1),\n        this.performQuickStream(\"What is Python?\", 2),\n        this.performQuickStream(\"What is Go?\", 3)\n      ];\n      \n      const results = await Promise.allSettled(promises);\n      const completionTime = performance.now();\n      \n      const successful = results.filter(r => r.status === 'fulfilled').length;\n      const failed = results.filter(r => r.status === 'rejected').length;\n      \n      console.log(`\\n‚úÖ Concurrent streaming test completed`);\n      console.log(`   Successful streams: ${successful}`);\n      console.log(`   Failed streams: ${failed}`);\n      console.log(`   Total duration: ${(completionTime - startTime).toFixed(2)}ms\\n`);\n      \n    } catch (error) {\n      console.log(`‚ùå Concurrent streaming test failed: ${error}\\n`);\n    }\n  }\n  \n  private async performQuickStream(query: string, id: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      let chunkCount = 0;\n      \n      claudeHeadlessStreamingService.streamQuery(\n        query,\n        { timeout: 8000 },\n        (chunk) => {\n          if (chunkCount === 0) {\n            console.log(`üì• Stream ${id} started`);\n          }\n          chunkCount++;\n        },\n        (fullResponse) => {\n          console.log(`‚úÖ Stream ${id} completed (${chunkCount} chunks, ${fullResponse.length} chars)`);\n          resolve();\n        }\n      ).catch(reject);\n    });\n  }\n  \n  async testStreamingLatency(): Promise<void> {\n    console.log('‚è±Ô∏è Testing Streaming Latency...');\n    \n    const measurements: number[] = [];\n    const iterations = 3;\n    \n    for (let i = 1; i <= iterations; i++) {\n      console.log(`   Measurement ${i}/${iterations}...`);\n      \n      const startTime = performance.now();\n      let firstChunkTime: number | undefined;\n      \n      await claudeHeadlessStreamingService.streamQuery(\n        \"Say 'Hello' in one word.\",\n        { timeout: 5000 },\n        (chunk) => {\n          if (!firstChunkTime) {\n            firstChunkTime = performance.now();\n            measurements.push(firstChunkTime - startTime);\n          }\n        },\n        () => {}\n      );\n    }\n    \n    const avgLatency = measurements.reduce((a, b) => a + b, 0) / measurements.length;\n    const minLatency = Math.min(...measurements);\n    const maxLatency = Math.max(...measurements);\n    \n    console.log(`\\n‚úÖ Latency test completed`);\n    console.log(`   Average latency: ${avgLatency.toFixed(2)}ms`);\n    console.log(`   Min latency: ${minLatency.toFixed(2)}ms`);\n    console.log(`   Max latency: ${maxLatency.toFixed(2)}ms`);\n    console.log(`   Target: < 2000ms (${avgLatency < 2000 ? '‚úÖ' : '‚ùå'})\\n`);\n  }\n  \n  async testErrorHandling(): Promise<void> {\n    console.log('üö® Testing Error Handling...');\n    \n    try {\n      // Test with invalid session\n      await claudeHeadlessStreamingService.streamInSession(\n        'invalid-session-id',\n        'Hello',\n        {\n          onChunk: () => {},\n          onComplete: () => {},\n          onError: (error) => {\n            console.log(`‚úÖ Expected error caught: ${error.message}`);\n          }\n        }\n      );\n    } catch (error) {\n      console.log(`‚úÖ Error handling working correctly`);\n    }\n    \n    console.log();\n  }\n  \n  async testTimeoutHandling(): Promise<void> {\n    console.log('‚è∞ Testing Timeout Handling...');\n    \n    try {\n      const startTime = performance.now();\n      \n      await claudeHeadlessStreamingService.streamQuery(\n        \"Write a 10000 word essay about quantum computing.\",\n        { timeout: 1000 }, // Very short timeout\n        () => {},\n        () => {}\n      );\n      \n    } catch (error) {\n      const duration = performance.now() - startTime;\n      \n      if (error instanceof Error && error.message.includes('timeout')) {\n        console.log(`‚úÖ Timeout handling working correctly`);\n        console.log(`   Timed out after: ${duration.toFixed(2)}ms`);\n      } else {\n        console.log(`‚ùå Unexpected error: ${error}`);\n      }\n    }\n    \n    console.log();\n  }\n  \n  // ============================================================================\n  // Report Generation\n  // ============================================================================\n  \n  generateReport(): void {\n    console.log('üìä Test Results Summary');\n    console.log('=' .repeat(50));\n    \n    const totalTests = this.testResults.length;\n    const successfulTests = this.testResults.filter(t => t.success).length;\n    const failedTests = totalTests - successfulTests;\n    \n    console.log(`Total tests: ${totalTests}`);\n    console.log(`Successful: ${successfulTests} (${((successfulTests / totalTests) * 100).toFixed(1)}%)`);\n    console.log(`Failed: ${failedTests} (${((failedTests / totalTests) * 100).toFixed(1)}%)`);\n    console.log();\n    \n    // Latency analysis\n    const successfulLatencies = this.testResults\n      .filter(t => t.success && t.latency.timeToFirstChunk)\n      .map(t => t.latency.timeToFirstChunk!);\n    \n    if (successfulLatencies.length > 0) {\n      const avgLatency = successfulLatencies.reduce((a, b) => a + b, 0) / successfulLatencies.length;\n      console.log(`Average time to first chunk: ${avgLatency.toFixed(2)}ms`);\n      console.log(`Real-time threshold (< 2000ms): ${avgLatency < 2000 ? '‚úÖ PASSED' : '‚ùå FAILED'}`);\n    }\n    \n    console.log();\n    \n    // Individual test results\n    this.testResults.forEach((test) => {\n      const status = test.success ? '‚úÖ' : '‚ùå';\n      const latency = test.latency.timeToFirstChunk?.toFixed(2) || 'N/A';\n      const duration = test.latency.totalDuration?.toFixed(2) || 'N/A';\n      \n      console.log(`${status} ${test.testName}`);\n      console.log(`   First chunk: ${latency}ms, Total: ${duration}ms, Chunks: ${test.totalChunks}`);\n      \n      if (test.error) {\n        console.log(`   Error: ${test.error}`);\n      }\n    });\n    \n    console.log();\n    \n    if (failedTests === 0) {\n      console.log('üéâ All tests passed! Real-time streaming is working correctly.');\n    } else {\n      console.log(`‚ö†Ô∏è  ${failedTests} test(s) failed. Please review the issues above.`);\n    }\n  }\n}\n\n// ============================================================================\n// Main Execution\n// ============================================================================\n\nasync function main() {\n  const testSuite = new StreamingTestSuite();\n  \n  try {\n    await testSuite.runAllTests();\n    process.exit(0);\n  } catch (error) {\n    console.error('Test suite execution failed:', error);\n    process.exit(1);\n  }\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}
